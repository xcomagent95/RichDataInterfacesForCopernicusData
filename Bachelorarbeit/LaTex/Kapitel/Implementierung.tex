\newpage
\restoregeometry
\section{Implementierung}
\subsection{Softwarestack}
Die prototypische Entwicklung eines leichtgewichtigen Rich Data Interface für Copernicus-Daten erfolgte im Rahmen dieser Arbeit mit der Programmiersprache Python.
Diese ist nicht nur aufgrund ihrer Einfachheit vorteilhaft sondern erlaubt auch den Zugriff auf eine große Zahl von Packages für die unterschiedlichsten 
Anwendungsfälle. 
Weite Teile des Rich Data Interface wurden mithilfe des Flask-Frameworks umgesetzt. Dieses erlaubt das schnelle Entwickeln einer leichtgewichtigen API.   

\subsection{Struktur}
Die Anwendung ist in vier Python-Scripte aufgeteilt. Im api.py Script ist die API der Anwendung definiert. 
Die geordnete Abarbeitung der angelegten Jobs werden vom Script processing.py gesteuert. Die eigentlichen Prozesse sowie 
Hilfsfunktionen befinden sich im utils.py Script. Das test.py Script kann dazu genuzt werden um die Stabilität und Standardkonformität der API zu testen.

Diese Scripte verwalten Dateien in einem einfachen Verzeichnissystem. Templates für statische Ressourcen befinden sich im Verzeichnis \textit{templates/}. HTML-Dateien 
befinden sich im Verzeichnis \textit{templates/html/} und JSON-Dateien im Verzeichnis \textit{templates/json/}. Das Unterverzeichnis \textit{templates/json/processes/} enthält die 
Beschreibungen der von der Anwendung angebotenen Prozesse. 
Die Anwendung erlaubt das persistente hinterlegen von Sentinel-1 Datensätzen um zeitaufwendiges Herunterladen zu vermeiden. Diese Datensätze können im Verzeichnis \textit{data/} abgelegt werden. Jeder Sentinel-1 Datensatz enthält eine .kml-Datei welche 
Metadaten zum Datensatz enthält. Diese werden im Unterverzeichnis \textit{data/coverage/} abgelegt. 
Jeder angelegte Job, also jede auszuführende Instanz eines Prozesses erhält ein einzigartiges Verzeichnis innerhalb des Verzeichnisses \textit{jobs/}. In diesem 
Verzeichnis befinden sich eine Status- und Job-Datei sowie ein Footprint. Neben diesen Dateien enthält jedes Job-Verzeichnis ein Unterverzeichnis \textit{results/} in dem
die Ergebnisse des jeweiligen Jobs abgelegt werden.

Insgesamt handelt es sich bei der protypischen Implemntierung eines Rich Data Interfaces for Copernicus-Daten also um eine Anwendung welche Überschwemmungsmasken und Daten zur Hochwasseranalyse als Ressourcen bereitstellt.
Zugrill auf diese Ressourcen erhalten Nutzer über eine OGC API - Processes - Part 1: Core standardkonforme API. 

\subsection{Ressourcen}
Ressourcen sind die üer die Endpoints der API bereitgestellten Informationen und Dateien. Sie können in unterschiedlichen Repräsentationen vorliegen.
Die meisten angebotenen Ressourcen können um Media-Type \textit{text/html}, also als HTML-Dateien oder im Media-Type \textit{application/json} also als 
JSON-Dateien angefragt werden. Um aus diesen Dateien einen Response zu generieren werden .html-Dateien zuvor mit der Methode \textit{render\_template()}, welcher auch 
dynamische Inhalte übergeben werden können gerendert während .json-Dateien zunächst mit der Methode \textit{jsonify()} bearbeitet werden. Beide genannten Methoden
geben ein Response-Objekt zurück welches versandt werden kann.  

Die Struktur dieser Ressourcen ist in Schemata beschrieben. Diese definieren neben den Bezeichnungen für Elemente auch ihre Datentypen und 
ob sie optional sind oder nicht. Jede Ressource enthält eine Verknüpfungen zu sich selbst mit der Relation \textit{self} und eine Verknüpfung 
zur Ressource im jeweils anderen Media-Type mit der Relation \textit{alternate}. ??Übersicht über Ressourcen??

\subsection{Requirements Classes für Encodings}
In der Requirements Class JSON wird definiert welche Ressourcen im Media-Type \textit{application/json} angefragt werden können. Dazu gehören alle Responses der 
Endpunkte API Landing Page, API Definition, Conformance Deklaration, Prozess Liste, Prozess Beschreibung, Prozess Ausführung und Job Status welche mit dem 
HTTP-Statuscode 200 versandt werden. Da die prototypische Implementierung auch die Endpunkte Job Liste und Coverage bereitstellt können die korrespondierenden
Ressourcen auch im Media-Type \textit{application/json} angefragt werden.\\

In der Requirements-Class HTML werden analog zu Requirements Class JSON jene Ressourcen definiert welche im Media-Type \textit{text/html} angefragt werden können. Jedoch
entfällt in dieser Requirements-Class die Einschränkung auf bestimmte Endpunkte und alle Responses welche mit dem HTTP-Statuscode 200 versandt werden müssen den 
Media-Type \textit{text/html} unterstützen.\\
Stellen Endpoints ihre Ressourcen sowohl den Media-Type \textit{application/json} als auch \textit{text/html} zur Verfügung so können Nutzer diesen über den optional Parameter
\textit{f} oder \textit{content\_type} spezifizieren. Wird kein Media-Type über diese Parameter spezifiziert so wird standardmäßig der Media-Type \textit{text/html} verwendet. \\


\subsection{Requirements Class Core}
\subsubsection{HTTP 1.1}
Die Umsetzung der Requirements-Class HTTP 1.1 (RFC 2616) verlangt das die API exklusiv das HTTP 1.1 unterstützt. 
Falls die API ebenfalls HTTPS unterstützt muss ebenfalls HTTP over TLS (RFC 2818) eingehalten werden. 
Das Flask-Framework nutzt standardmäßig das HTTP 1.0. Teil des Flask-Frameworks ist die WSGI Bibliothek Werkzeug welche
das Implementieren von Webanwendungen erlaubt. Um die verwendete HTTP-Version von 1.0 auf 1.1 umzustellen müssen Variablen 
in Werkzeug angepasst werden. Nach dem Import der Module WSGIRequestHandler und BaseWSGIServer kann in beiden die 
Version des HTTP Protokolls angepasst werden (siehe Anhang \ref{appendixconfWerkzeug}). 

In dieser Requirements-Class werden zudem alle HTTP-Statuscodes gelistet die Nutzer von einer standardkonformen Implementierung mindestens erwarten können. 
\begin{table}[H]
    \caption{Vorgesehene HTTP-Statuscodes \cite{ogc_api_processes_core}}
    \centering
    \begin{tabular}{c c} 
        HTTP-Statuscode & Bedeutung\\ 
        \hline
        200 & OK\\
        201 & Created\\
        204 & No Content\\
        400 & Bad Request\\
        401 & Unauthorized\\
        403 & Forbidden\\
        404 & Not Found\\
        405 & Method Not Allowed\\
        406 & Not Acceptable\\
        410 & Gone\\
        429 & Too Many Requests\\
        500 & Internal Server Error\\
        501 & Not Implemented\\
    \end{tabular}\label{httpcodes}
\end{table}
Alle erfolgreichen Anfragen welche eine Resource liefern mit dem HTTP-Statuscode 200 beantwortet. Die Verwendung nicht zulässiger HTTP-Methoden resultieren 
in Antworten mit dem Status-Code 405 während Anfragen für nicht unterstütze Media-Types mit dem Status-Code 406 beantwortet werden. Kommt es zu Fehlern bei der Ausführung 
des Programmcodes antwortet die Anwendung mit dem HTTP-Statuscode 500. Werden durch eine Anfrage Ressourcen neu erzeugt oder nicht gefunden antwortet die Anwendung mit 
den HTTP-Statuscodes 201 beziehungsweise 404. Der Standard erlaubt die Nutzung weiterer HTTP-Statuscodes \cite{ogc_api_processes_core}.

\subsubsection{Limit Paramter}
Der \textit{limit}-Parameter wird von den Endpoints Process List und Job List unterstützt. Mit ihm kann gesteuert werden wie viele Elemente im Response gelistet werden. 
Der \textit{limit}-Parameter ist optional. Ist er nicht Teil eines Requests werden standardmäßig 10 Elemente zurückgegeben. Es können maximal 1000 Elemente angefragt werden.
Ergibt die Überprüfung des \textit{limit}-Parameters das Werte außerhalb des gültigen Wertebereichs von 0 bis 1000 angefragt werden wird der Parameter auf 10 zurückgesetzt. 
Ein Response kann weniger, aber nie mehr Elemente als durch den \textit{limit}-Parameter spezifiziert werden enthalten \ref{appendixlimityaml}. 

\subsubsection{API Landig Page}
Der API Landing Page kann über den URL \textit{http://HOST:PORT/?f=<MEDIA-TYPE>} angefragt werden und liefert als Resource die 
API Landing Page (siehe Anhang \ref{appendixlandngPageyaml}). 
Die einzig zulässige HTTP-Methode für diesen Endpoint ist die HTTP-Get Methode.\\ 
Die API Landing Page kann Eintrittspunkt zu allen anderen Funktionalitäten der Anwendung bezeichnet werden. Sie enthält Verknüpfungen zu den Endpoints, API Landing Page, API Definition, 
Conformance, Process List, Process Description, Job List und Coverage.\\
Die API Landing Page kann in den Media-Types \textit{text/html} (siehe Anhang \ref{appendixlandingPageHTML}) und \textit{application/json} 
(siehe Anhang \ref{appendixlandingPageJSON}) abgerufen werden.\\
 
Wird ein Request für gültig befunden so wird, je nach gewähltem Media-Type, ein passender Response generiert. 
Dieser wird zusammen mit dem \textit{link}- und \textit{resource}-Header versandt (siehe Anhang \ref{appendixLandingPage}). 

!Pseudode!

\subsubsection{API Definition}
Der API Definition Endpoint kann über den URL \textit{http://HOST:PORT/api?f=<MEDIA-TYPE>} angefragt werden und liefert als Ressource die API Definition (siehe Anhang !ref einfügen!).
Auch für diesen Endpoint ist die einzig zulässige HTTP-Methode Get. 
Die API Definition enhält detailierte Informationen zur API. In ihr sind alle verfügbaren Endpoints mit ihren Parametern und Responses aufgeführt. Auch die API Definition kann in den Media-Types
textit{text/html} (siehe Anhang !ref einfügen!) und \textit{application/json} (siehe Anhang !ref einfügen!) abgerufen werden.\\
Nach einem gültigen Request wird ein zum angefrgten Media-Type passen Response generiert. Dieser wird zusammen mit dem \textit{link}- und \textit{resource}-Header versandt (siehe Anhang \ref{appendixAPIDefinition}). 

!Pseudode!
\subsubsection{Conformance Decalration}
Der Endpoint Conformance Declaration kann über den URL \textit{http://HOST:PORT/conformance?f=<MEDIA-TYPE>} angefragt werden und liefert als Ressource die Conformance Declaration (siehe Anhang \ref{appendixconfClassesyaml}).
Get ist ebenfalls die einzige zulässige HTTP-Methode für Requests an diesen Endpoint.

Die Conformance Declaration enthält Verknüpfungen zu allen von der Anwendung implementierten Requiremnets Classes und steht in den Media-Types textit{text/html} (siehe Anhang \ref{appendixconfClassesHTML}) und 
\textit{application/json} (siehe Anhang \ref{appendixconfClassesJSON}) zu Verfügung.

Gültige Requests Lösen die Generierung eines Responses im angefragten Media-Type aus. Der Response wird zusammen mit \textit{link}- und \textit{resource}-Header versandt (siehe Anhang \ref{appendixConformance}).
!Pseudode!

\subsubsection{Process List Endpoint}
Der Process List Endpoint ist über den URL \textit{http://HOST:PORT/processes?f=<MEDIA-TYPE>&limit=<INTEGRER>} angefragt werden. 
Request sind nur mit der HTTP-Methode Get zulässig. Als Ressource erhalten nutzer eine detaillierte Liste der durch die Anwendung agebotenen Prozesse (siehe Anhang \ref{appendixprocessListyaml}). In dieser Listee finden sich die Bezeichnungen, 
Steueroptionen sowie die 
Ein- und Ausgaben der Prozesse. Die Process Liste kann in den Media-Types \textit{text/html} (siehe Anhang \ref{appendixprocessListHTML}) und \textit{application/json} angefragt werden. 

Die Generierung eines Responses im angefrgten Media-Type wird nach einem gültigen Request gestartet. Dazu werden zunächst im \textit{templates/json/processes} Verzeichnis hinterlegten Prozess Beschreibungen geladen und in ein Array geschrieben. 
Dieses kann nun falls der Media-Type \textit{application/json} zu einem Objekt hinzugefügt werden welches zusärtzlich die Verknüfungen zur Ressource enthält. Wurde der Media-Type \textit{text/html} angefragt wird das Array zusammen mit dem HTML-Template dem 
gerendert. 
Der Response wird zusammen mit \textit{link}- und \textit{resource}-Header versandt (siehe Anhang \ref{appendixProcessList}).
!Pseudode!

\subsubsection{Process Description Endpoint}
Unter dem URL \textit{http://HOST:PORT/processes/<processID>?f=<MEDIA-TYPE>} kann der Process Description Endpoint angefragt werden. Welche Prozessdetails zurückgegeben werden hängt vom \textit{processID}-Paramter ab. Alle Prozesse werden über eine 
eindeutige Bezeichnung, die \textit{processID} gekennzeichnet. Sie kann der Prozess Liste entnommen werden. Um eine Prozess Beschreibung anzufragen darf nur die HTTP-Get Methode verwendet werden.   
Als Ressource liefert der Endpoint eine detaillierte Beschreibung des im Request spezifizierten Prozesses (siehe Anhang \ref{appendixoutputDescriptionyaml}). Diese Beschreibung enthält Informationen zu den Steueroptionen sowie den Ein- und Ausgaben des Prozesses.
Wie die Prozess Liste kann die auch die Process Beschreibung im Media-Type \textit{text/html} oder \textit{application/json} angefragt werden. 
Die Generierung eines Responses verläuft ähnlich der der Prozess Liste. Zunächst wird die Prozess Beschreibung des angefragten Prozesses geladen. Soll ein Response mit dem Media-Type \textit{application/json} generiert werden wird diese versandt. 
Für Request mit dem Media-Type \textit{text/html} wird die Prozessbeschreibung zusammen mit einem Template an den Renderer übergegen. 
!Pseudode!
\subsubsection{Prozess Ausführung}
?Wie erreiche ich den Endpoint?
?Welche Ressource liefert der Endpoint?
?Welche HTTP-Methoden sind erlaubt?
?Was ist der Inhalt der Resource?
?Welche Media Types gibt es?
?Wie läuft die generierung des Response ab und was enthält dieser?
!Pseudode!
\subsubsection{Job Status}?Wie erreiche ich den Endpoint?
?Welche Ressource liefert der Endpoint?
?Welche HTTP-Methoden sind erlaubt?
?Was ist der Inhalt der Resource?
?Welche Media Types gibt es?
?Wie läuft die generierung des Response ab und was enthält dieser?
!Pseudode!
\subsubsection{Job Resultate}
?Wie erreiche ich den Endpoint?
?Welche Ressource liefert der Endpoint?
?Welche HTTP-Methoden sind erlaubt?
?Was ist der Inhalt der Resource?
?Welche Media Types gibt es?
?Wie läuft die generierung des Response ab und was enthält dieser?
!Pseudode!
\subsection{Requirements Class OGC Process Description}
\subsection{Requirements Class Job List}
?Wie erreiche ich den Endpoint?
?Welche Ressource liefert der Endpoint?
?Welche HTTP-Methoden sind erlaubt?
?Was ist der Inhalt der Resource?
?Welche Media Types gibt es?
?Wie läuft die generierung des Response ab und was enthält dieser?
!Pseudode!
\subsection{Requirements Class Dismiss}
?Wie erreiche ich den Endpoint?
?Welche Ressource liefert der Endpoint?
?Welche HTTP-Methoden sind erlaubt?
?Was ist der Inhalt der Resource?
?Welche Media Types gibt es?
?Wie läuft die generierung des Response ab und was enthält dieser?
!Pseudode!
\subsection{Requirements Class OpenAPI 3.0}
Der OGC API - Processes - Part 1: Core Standard macht über die eigentlichen Funktionen der API auch Vorgaben zur Art der Dokumentation der API. Hierfür soll der 
OpenAPI 3.0 Standard genutzt werden. 
\subsection{Prozesse}
\subsubsection{Echo}
Da eine standardkonforme API mindestens einen testbaren Prozess anbieten muss ist der Echo-Prozess ebenfalls Teil der prototypischen Implementierung. 
Dieser nimmt einen beliebigen Wert entgegen. Nach einer kurzen, simulierten Bearbeitungszeit kann dieser wieder als Resultat abgefragt werden. 

Nach dem Start eines Echo Prozesses wird zunächst überprüft ob der Job nicht den Status \textit{dismissed} aufweist. Wäre dies der Fall wird die Ausführung abgebrochen. 
Andernfalls wird der \textit{started}-Eintrag in der status.json mit dem aktuellen Zeitstempel versehen und der zurückzugebende Wert aus den Eingaben des Jobs gelesen.
Schlägt dies fehl wird der \textit{status}-Eintrag in der status.json auf \textit{failed} gesetzt und der Ausführung abgebrochen. 
Anschließend wartet das Programm fünf Sekunden. Nach einer erneuten Prüfung des Job-Status wird das Ergebnis als .json in das \textit{results/}-Verzeichnis des Jobs geschrieben.
Diese results.json enthält den Eingabewert und die Nachricht das es sich um ein Echo handelt. 
Als letzter Schritt wird der Job-Status, der Fortschritt, der Infotext sowie der Beendigungszeitpunkt in der Status-Datei des Jobs aktualisiert \ref{appendixEchoProcess}. 
\subsubsection{Überflutungsmonitoring}
\subsection{Zusätzliche Funktionalitäten}
\subsubsection{Coverage} 
Der nicht im Standard definierte Coverage Endpoint kann über den URL \textit{http://HOST:PORT/coverage?f=<MEDIA-TYPE>} erreicht werden. Als Ressource liefert er eine Liste aller Sentinel-1 Datensätze welche persistent gespiechert sind. 
Jobs welche auf diese Datensätze zugreifen können schneller abgearbeitet werden da ein zeitaufwendiges herunterladen der Datensätze entfällt. Die Coverage Ressource kann nur mit der HTTP-Get Methode angefragt werden. 

?Was ist der Inhalt der Resource?
?Welche Media Types gibt es?
?Wie läuft die generierung des Response ab und was enthält dieser?
\newpage
\restoregeometry
\section{Implementierung}
\subsection{Softwarestack}
\subsection{Programmstruktur}
\subsection{Requirements Classes für Encodings}
\subsubsection{Requirements Class JSON}
In der Requirements Class JSON wird definiert welche Ressourcen im Media-Type $application/json$ angefragt werden können. Dazu gehören alle Responses der 
Endpunkte API Landing Page, API Definition, Conformance Deklaration, Prozess Liste, Prozess Beschreibung, Prozess Ausführung und Job Status welche mit dem 
HTTP-Statuscode 200 versandt werden. Da die prototypische Implementierung auch die Endpunkte Job Liste und Coverage bereitstellt können die korrespondierenden
Ressourcen auch im Media-Type $application/json$ angefragt werden.
Die statischen .json-Dateien für die Endpunkte API Landing Page, API Definition, Conformance Deklaration, Prozess Liste, Prozess Beschreibung sind im Verzeichnis
$/templates/json$ hinterlegt. Die .json-Dateien der angelegten Jobs finden sich jeweils in den Job-Verzeichnissen unter $/jobs/<jobID>$ während die .kml-Dateien
welche die Informationen für den Coverage-Endpoint beinhalten unter $data/coverage$ gespeichert sind. Werden Ressourcen im Media-Type $application/json$ angefragt
müssen also zunächst die entsprechenden .json-Dateien geladen, je nach Endpunkt variiert oder kombiniert und vor dem versenden mit der Funktion $jsonify()$
vorbereitet werden. 

\subsubsection{Requirements Class HTML}
In der Requirements-Class HTML werden analog zu Requirements Class JSON jene Ressourcen definiert welche im Media-Type $text/html$ angefragt werden können. Jedoch
entfällt in dieser Requirements-Class die Einschränkung auf bestimmte Endpunkte und alle Responses welche mit dem HTTP-Statuscode 200 versandt werden müssen den 
Media-Type $text/html$ unterstützen. 

\subsection{Requirements Class Core}
\subsubsection{HTTP 1.1}
Die Umsetzung der Requirements-Class HTTP 1.1 (RFC 2616) verlangt das die API exklusiv das HTTP 1.1 unterstützt. 
Falls die API ebenfalls HTTPS unterstützt muss ebenfalls HTTP over TLS (RFC 2818) eingehalten werden. 
Das Flask-Framework nutzt standardmäßig das HTTP 1.0. Teil des Flask-Frameworks ist die WSGI Bibliothek Werkzeug welche
das Implementieren von Webanwendungen erlaubt. Um die verwendete HTTP-Version von 1.0 auf 1.1 umzustellen müssen Variablen 
in Werkzeug angepasst werden. Nach dem Import der Module WSGIRequestHandler und BaseWSGIServer kann in beiden die 
Version des HTTP Protokolls angepasst werden (siehe Anhang \ref{appendixconfWerkzeug}). 

In dieser Requirements-Class werden zudem alle HTTP-Statuscodes gelistet die Nutzer von einer standardkonformen Implementierung mindestens erwarten können. 
\begin{table}[H]
    \caption{Typische HTTP-Statuscodes \cite{ogc_api_processes_core}}
    \centering
    \begin{tabular}{c c} 
        HTTP-Statuscode & Bedeutung\\ 
        \hline
        200 & OK\\
        201 & Created\\
        204 & No Content\\
        400 & Bad Request\\
        401 & Unauthorized\\
        403 & Forbidden\\
        404 & Not Found\\
        405 & Method Not Allowed\\
        406 & Not Acceptable\\
        410 & Gone\\
        429 & Too Many Requests\\
        500 & Internal Server Error\\
        501 & Not Implemented\\
    \end{tabular}\label{httpcodes}
\end{table}
Alle erfolgreichen Anfragen welche eine Resource liefern mit dem HTTP-Statuscode 200 beantwortet. Die Verwendung nicht zulässiger HTTP-Methoden resultieren 
in Antworten mit dem Status-Code 405 während Anfragen für nicht unterstütze Encodings mit dem Status-Code 406 beantwortet werden. Kommt es zu Fehlern bei der Ausführung 
des Programmcodes antwortet die Anwendung mit dem HTTP-Statuscode 500. Werden durch eine Anfrage Ressourcen neu erzeugt oder nicht gefunden antwortet die Anwendung mit 
den HTTP-Statuscodes 201 beziehungsweise 404. Der Standard erlaubt die Nutzung weiterer HTTP-Statuscodes.

\subsubsection{API Landig Page}
Der erste im Standard definierte Endpoint kann über den URL \textit{http://HOST:PORT/?f=<text/html | application/json>} aufgerufen werden und liefert als Resource die 
Landing Page der API. Diese kann als Eintrittspunkt zu allen anderen Funktionalitäten angesehen werden. Sie enthält Verknüpfungen zu den Endpoints API Definition, 
Conformance Declaration, Process List, Process Description, Job List und Coverage. Der Endpoint kann nur mit der HTTP-Get Methode verwendet werden. 
Die Resource wird als HTML- aber auch als JSON-Dokument angeboten. Der Nutzer kann über die optionalen Parameter $f$ oder $content\_type$ steuern welcher Media-Type der Response 
nutzen soll. Wird eim Request akzeptiert so wird, je nach gewähltem Media-Type, ein Response aus einer statischen .html- oder .json-Datei generiert und mit zusätzlichen 
HTTP-Headern versandt. Der $link$-Header liefert einen URL zur angefragten Resource während der $resource$-Header die angefragte Ressource identifiziert. 
Die Landing Page wird hier mit $landingPage$ identifiziert (siehe Anhang \ref{appendixLandingPage}). 

\subsubsection{API Definition}
Unter dem URL \textit{http://HOST:PORT/api?f=<text/html | application/json>} kann der API Definition Endpoint erreicht werden. Dieser liefert eine detaillierte Beschreibung
der API und ihrer Funktionen.  Da eine andere Requirements-Class die Dokumentation im  OpenAPI 3.0 Format fordert sind die von diesem Endpunkt bereitgestellten Ressourcen aus 
einer solchen abgeleitet. In dieser Form der Dokumentation werden neben einer allgemeinen Beschreibung sämtliche Endpoints mit ihren zu erwartenden HTTP-Statuscodes und 
Responses beschrieben. Zusätzlich erfolgt einen Auflistung aller Schemata nach welchen von der API angebotene Ressourcen strukturiert sind. Die API Beschreibung wird
als HTML- oder JSON-Dokument angeboten. Die Wahl des Media-Type wird auch hier über die optionalen Parameter $f$ oder $content\_type$ gesteuert. Die angefragten Ressourcen 
werden auch hier nicht dynamisch sondern aus statischen .html- beziehungsweise .json-Dateien generiert. Nach einem erfolgreichen Request werden sie zusammen mit 
einem $link$- und $resource$-Header versandt. Der Endpoint erlaubt nur die Nutzung der HTTP-Get Methode (siehe Anhang \ref{appendixAPIDefinition}).

\subsubsection{Conformance Endpoint}
Fragt ein Nutzer den Conformance Endpoint an so erhält er Informationen zur Konformität der API zum OGC API - Processes - Part 1: Core Standard. 
In der Ressource werden alle Requirements-Classes gelistet welche von der API implementiert werden. Über die optionalen Parameter $f$ oder $content\_type$ kann
im Request spezifiziert werden in welchem Media-Type die angefragte Ressource versandt werden soll. Der Endpoint erlaubt nur die Nutzung der HTTP-Get Methode
(siehe Anhang \ref{appendixConformance}). 

\subsubsection{Processes Endpoint}
Damit der Nutzer schnell einen Überblick über die von der API angebotenen Prozesse erhält enthält die Requirements-Class Core Vorgaben für einen entsprechenden Endpunkt.
Dieser liefert als Resource eine detaillierte Liste der angebotenen Prozesse als HTML- oder JSON-Dokument. In dieser Liste werden die Bezeichnung, die Steueroptionen sowie
die Ein- und Ausgaben jedes angebotenen Prozesses gelistet. Die nötigen Informationen werden statischen Prozess Beschreibungen entnommen.
Auch Requests an diesen Endpoint können mit den optional Parametern $f$ oder $content\_type$ zur Spezifizierung des Media-Types aber auch mit dem $limit$ Parameter versehen werden 
welches die Anzahl der wiedergegebene Prozesse steuert. Auch dieser Endpoint erlaubt nur die Nutzung der HTTP-Get Methode. 
Nach Überprüfung aller Parameter werden zunächst alle Process Descriptions aus dem Verzeichnis $/templates/json/processes$ geladen und in einem Array gespeichert.
(siehe Anhang \ref{appendixProcessList})

\subsubsection{Process Endpoint}
\subsubsection{Prozess Ausführung}
\subsubsection{Job Status}
\subsubsection{Job Resultate}
\subsection{Requirements Class OGC Process Description}
\subsection{Requirements Class Job List}
\subsection{Requirements Class Dismiss}
\subsection{Requirements Class OpenAPI 3.0}
\subsection{Prozesse}
\subsubsection{Echo}
\subsubsection{Überflutungsmonitoring}
\subsection{Zusätzliche Funktionalitäten}
\subsubsection{Coverage} 
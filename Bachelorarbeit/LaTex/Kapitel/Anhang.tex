\newpage
\restoregeometry
\counterwithin{lstlisting}{section}

\section{Schemata}
\renewcommand{\lstlistingname}{Pseudocode}  

\subsection{Ablauf eines Requests an den API Landing Page Endpoint}
\begin{algorithm}[H]
\caption{Ablauf eines Requests an den API Landing Page Endpoint}\label{appendixpsedoLandingPage}
\scriptsize
\begin{algorithmic}     
    \STATE HTTP-Methode $\gets$ Anfrage.HTTP-Methode
    \STATE Encoding $\gets$ Anfrage.f
    \IF{HTTP-Methode != GET}
        \RETURN{HTTP-Statuscode 405}
    \ELSE{}
        \STATE \hskip0.5em \textbf{try}
        \begin{ALC@g}
        \IF{Encoding == text/html \OR Encoding == None}
            \STATE Response $\gets$ render\_template(templates/html/landingPage.html)
            \STATE Link-Header $\gets$ http://HOST:PORT/?f=text/html
            \STATE Resource-Header $\gets$ landingPage
            \RETURN{HTTP-Statuscode 200 \AND Antwort mit Link- und Resource-Header}
        \ELSIF{Encoding == application/json}
            \STATE JSON $\gets$ open(templates/json/landingPage.json)
            \STATE Response $\gets$ jsonify(Datei)
            \STATE Link-Header $\gets$ http://HOST:PORT/?f=application/json
            \STATE Resource-Header $\gets$ landingPage
            \RETURN{HTTP-Statuscode 200 \AND Antwort mit Link- und Resource-Header}
        \ELSE{}
            \RETURN{HTTP-Statuscode 406}
        \ENDIF{}
        \end{ALC@g}
        \STATE \hskip0.5em \textbf{exept}
        \begin{ALC@g}
            \RETURN{HTTP-Statuscode 500}
        \end{ALC@g}
    \ENDIF{}
\end{algorithmic}
\end{algorithm}

\subsection{Ablauf eines Requests an den API Definition Endpoint}
\begin{algorithm}[H]
\caption{Ablauf eines Requests an den API Definition Endpoint}\label{appendixpsedoAPIDefinition}
\scriptsize
\begin{algorithmic}     
    \STATE HTTP-Methode $\gets$ Anfrage.HTTP-Methode
    \STATE Encoding $\gets$ Anfrage.f
    \IF{HTTP-Methode != GET}
        \RETURN{HTTP-Statuscode 405}
    \ELSE{}
        \STATE \hskip0.5em \textbf{try}
        \begin{ALC@g}
        \IF{Encoding == text/html \OR Encoding == None}
            \STATE Response $\gets$ render\_template(templates/html/apiDefinition.html)
            \STATE Link-Header $\gets$ http://HOST:PORT/api?f=text/html
            \STATE Resource-Header $\gets$ apiDefinition
            \RETURN{HTTP-Statuscode 200 \AND Antwort mit Link- und Resource-Header}
        \ELSIF{Encoding == application/json}
            \STATE JSON $\gets$ open(templates/json/apiDefinition.json)
            \STATE Response $\gets$ jsonify(Datei)
            \STATE Link-Header $\gets$ http://HOST:PORT/api?f=application/json
            \STATE Resource-Header $\gets$ apiDefinition
            \RETURN{HTTP-Statuscode 200 \AND Antwort mit Link- und Resource-Header}
        \ELSE{}
            \RETURN{HTTP-Statuscode 406}
        \ENDIF{}
        \end{ALC@g}
        \STATE \hskip0.5em \textbf{exept}
        \begin{ALC@g}
            \RETURN{HTTP-Statuscode 500}
        \end{ALC@g}
    \ENDIF{}
\end{algorithmic}
\end{algorithm}
    
\subsection{Ablauf eines Requests an den Conformance Endpoint}
\begin{algorithm}[H]
\caption{Ablauf eines Requests an den Conformance Endpoint}\label{appendixpsedoConformance}
\scriptsize
\begin{algorithmic}     
    \STATE HTTP-Methode $\gets$ Anfrage.HTTP-Methode
    \STATE Encoding $\gets$ Anfrage.f
    \IF{HTTP-Methode != GET}
        \RETURN{HTTP-Statuscode 405}
    \ELSE{}
        \STATE \hskip0.5em \textbf{try}
        \begin{ALC@g}
        \IF{Encoding == text/html \OR Encoding == None}
            \STATE Response $\gets$ render\_template(templates/html/confClasses.html)
            \STATE Link-Header $\gets$ http://HOST:PORT/conformance?f=text/html
            \STATE Resource-Header $\gets$ conformance
            \RETURN{HTTP-Statuscode 200 \AND Antwort mit Link- und Resource-Header}
        \ELSIF{Encoding == application/json}
            \STATE JSON $\gets$ open(templates/json/confClasses.json)
            \STATE Response $\gets$ jsonify(Datei)
            \STATE Link-Header $\gets$ http://HOST:PORT/conformance?f=application/json
            \STATE Resource-Header $\gets$ conformance
            \RETURN{HTTP-Statuscode 200 \AND Antwort mit Link- und Resource-Header}
        \ELSE{}
            \RETURN{HTTP-Statuscode 406}
        \ENDIF{}
        \end{ALC@g}
        \STATE \hskip0.5em \textbf{exept}
        \begin{ALC@g}
            \RETURN{HTTP-Statuscode 500}
        \end{ALC@g}
    \ENDIF{}
\end{algorithmic}
\end{algorithm}

\subsection{Ablauf eines Requests an den Process List Endpoint}
\begin{algorithm}[H]
\caption{Ablauf eines Requests an den Process List Endpoint}\label{appendixpsedoProcessList}
\scriptsize
\begin{algorithmic}     
    \STATE HTTP-Methode $\gets$ Anfrage.HTTP-Methode
    \STATE Encoding $\gets$ Anfrage.f
    \STATE Limit $\gets$ Anfrage.limit
    \IF{HTTP-Methode != GET}
        \RETURN{HTTP-Statuscode 405}
    \ELSE{}
        \STATE \hskip0.5em \textbf{try}
        \begin{ALC@g}
            \IF{Limit == None \OR Limit <= 0 \OR Limit > 10000}
                \STATE Limit $\gets$ 10
            \ELSE{}
                \STATE Limit $\gets$ Anfrage.limit
            \ENDIF
        \IF{Encoding == text/html \OR Encoding == None}
            \STATE Process List $\gets$ []
            \STATE Processes $\gets$ List of Process descriptions in templates/json/processes
            \FOR{Process \textbf{in} Processes}
                \STATE JSON $\gets$ open(jobs/Job-ID/status.json)
                \STATE Process List \textbf{append} JSON
            \ENDFOR{}
            \STATE Response $\gets$ render\_template(templates/html/processList.html, Process List[0:Limit])
            \STATE Link-Header $\gets$ http://HOST:PORT/processList?f=application/json
            \STATE Resource-Header $\gets$ processList
            \RETURN{HTTP-Statuscode 200 \AND Antwort mit Link- und Resource-Header}
        \ELSIF{Encoding == application/json}
            \STATE Process List $\gets$ []
            \STATE Processes $\gets$ List of Process descriptions in templates/json/processes
            \FOR{Process \textbf{in} Processes}
                \STATE JSON $\gets$ open(jobs/Job-ID/status.json)
                \STATE Process Liste \textbf{append} JSON
            \ENDFOR{}
            \STATE \textbf{add} Links \textbf{to} Process Liste
            \STATE Response $\gets$ jsonify(Process Liste[0:Limit])
            \STATE Link-Header $\gets$ http://HOST:PORT/processList?f=application/json
            \STATE Resource-Header $\gets$ processList
            \RETURN{HTTP-Statuscode 200 \AND Antwort mit Link- und Resource-Header}
        \ELSE{}
            \RETURN{HTTP-Statuscode 406}
        \ENDIF{}
        \end{ALC@g}
        \STATE \hskip0.5em \textbf{exept}
        \begin{ALC@g}
            \RETURN{HTTP-Statuscode 500}
        \end{ALC@g}
    \ENDIF{}
\end{algorithmic}
\end{algorithm}

\subsection{Ablauf eines Requests an den Process Description Endpoint}
\begin{algorithm}[H]
\caption{Ablauf eines Requests an den Process Description Endpoint}\label{appendixpsedoProcessDescription}
\scriptsize
\begin{algorithmic}     
    \STATE HTTP-Methode $\gets$ Anfrage.HTTP-Methode
    \STATE Encoding $\gets$ Anfrage.f
    \STATE Process-ID $\gets$ Anfrage.processID
    \IF{HTTP-Methode != GET}
        \RETURN{HTTP-Statuscode 405}
    \ELSE{}
        \STATE \hskip0.5em \textbf{try}
        \begin{ALC@g}
            \IF{Encoding == text/html \OR Encoding == None}
                \IF{templates/json/processes/Process-ID.json exists}
                    \STATE JSON $\gets$ open(json/processes/Process-ID.json)
                    \STATE Response $\gets$ render\_template(templates/html/process.html, JSON)
                    \STATE Link-Header $\gets$ http://HOST:PORT/processes/<processID>?f=text/html
                    \STATE Resource-Header $\gets$ Process-ID
                    \RETURN{HTTP-Statuscode 200 \AND Antwort mit Link- und Resource-Header}
                \ELSE{}
                    \STATE Exception $\gets$ No such process exception
                    \STATE Resource-Header $\gets$ no-such-process
                    \RETURN{HTTP-Statuscode 404 \AND Exception mit Resource-Header}
                \ENDIF{}
            \ELSIF{Encoding == application/json}
                \IF{templates/json/processes/Process-ID.json exists}
                    \STATE JSON $\gets$ open(json/processes/Process-ID.json)
                    \STATE Response $\gets$ jsonify(JSON)
                    \STATE Link-Header $\gets$ http://HOST:PORT/processes/<processID>?f=application/json
                    \STATE Resource-Header $\gets$ Process-ID
                    \RETURN{HTTP-Statuscode 200 \AND Antwort mit Link- und Resource-Header}
                \ELSE{}
                    \STATE Exception $\gets$ No such process exception
                    \STATE Resource-Header $\gets$ no-such-process
                    \RETURN{HTTP-Statuscode 404 \AND Exception mit Resource-Header}
                \ENDIF{}
        \ELSE{}
            \RETURN{HTTP-Statuscode 406}
        \ENDIF{}
        \end{ALC@g}
        \STATE \hskip0.5em \textbf{exept}
        \begin{ALC@g}
            \RETURN{HTTP-Statuscode 500}
        \end{ALC@g}
    \ENDIF{}
\end{algorithmic}
\end{algorithm}

\subsection{Ablauf eines Requests an den Job Status Endpoint}
\begin{algorithm}[H]
\scriptsize
\caption{Ablauf eines Requests an den Job Status Endpoint}\label{appendixpsedoJobStatus}
\begin{algorithmic}     
    \STATE HTTP-Methode $\gets$ Anfrage.HTTP-Methode
    \STATE Encoding $\gets$ Anfrage.f
    \STATE Job-ID $\gets$ Anfrage.jobID
    \IF{HTTP-Methode == GET}
        \STATE Test
    \ELSIF{HTTP-Methode == DELETE}
        \STATE Test
    \ELSE{}
        \RETURN{HTTP-Statuscode 405}
    \ENDIF{}
\end{algorithmic}
\end{algorithm}

\renewcommand{\lstlistingname}{Quellcode}
\section{Quellcodeverzeichnis}
\subsection{Konfiguration von Werkzeug auf HTTP 1.1}
\begin{lstlisting}[caption={Konfiguration von Werkzeug auf HTTP 1.1}, style = Python]
    from flask import Flask
    from werkzeug.serving import WSGIRequestHandler
    from werkzeug.serving import BaseWSGIServer
    WSGIRequestHandler.protocol_version = "HTTP/1.1"
    BaseWSGIServer.protocol_version = "HTTP/1.1"
\end{lstlisting}\label{appendixconfWerkzeug}

\subsection{Quellcode Landing Page Endpoint}
\begin{lstlisting}[caption={Landing Page Endpoint}, style = Python]
#landingpage endpoint
@app.route('/',  methods = ['GET'])
def getLandingPage():
    app.logger.info('/') 
    try:
        if(request.content_type == "text/html" or
        request.args.get('f')=="text/html" or 
        request.args.get('f') == None):
                response = render_template('html/landingPage.html') 
                return response, 200, {
                "link": "localhost:5000/?f=text/html", 
                "resource": "landingPage"
                } 
        elif(request.content_type == "application/json" or
        request.args.get('f')=="application/json"): 
            file = open('templates/json/landingPage.json',) 
            payload = json.load(file) 
            file.close() 
            response = jsonify(payload) 
            return response, 200, {
                "link": "localhost:5000/?f=application/json", 
                "resource": "landingPage"} 
        else:
            return "HTTP status code 406: not acceptable", 406 
        except:
            return "HTTP status code 500: internal server error", 500 
\end{lstlisting}\label{appendixLandingPage}

\newpage
\subsection{Quellcode API Definition Endpoint}
\begin{lstlisting}[caption={API Definition Endpoint}, style = Python]
#api endpoint
@app.route('/api',  methods = ['GET']) 
def getAPIDefinition():
    app.logger.info('/api') 
    try:
        if(request.content_type == "text/html" or
        request.args.get('f')=="text/html" or 
        request.args.get('f') == None): 
            response = render_template('html/apiDefinition.html') 
            return response, 200, {
                "link": "localhost:5000/apiDefinition?f=text/html", 
                "resource": "apiDefinition"} 
        elif(request.content_type == "application/json" or 
        request.args.get('f')=="application/json"): 
            file = open('templates/json/apiDefinition.json',) 
            payload = json.load(file) 
            file.close() #close apiDefinition.json
            response = jsonify(payload) 
            return response, 200, {
                "link": "localhost:5000/api?f=application/json", 
                "resource": "apiDefinition"} 
        else:
            return "HTTP status code 406: not acceptable", 406 
    except:
        return "HTTP status code 500: internal server error", 500
\end{lstlisting}\label{appendixAPIDefinition}

\newpage
\subsection{Quellcode Conformance Endpoint}
\begin{lstlisting}[caption={Conformance Endpoint}, style = Python]
#conformance endpoint
@app.route('/conformance',  methods = ['GET'])
def getConformance():
    app.logger.info('/conformance') 
    try:
        if(request.content_type == "text/html" or 
        request.args.get('f')=="text/html" or 
        request.args.get('f') == None): 
            response = render_template('html/confClasses.html') 
            return response, 200, {
                "link": "localhost:5000/conformance?f=text/html", 
                "resource": "conformance"}
        elif(request.content_type == "application/json" or 
        request.args.get('f')=="application/json"): 
            file = open('templates/json/confClasses.json',)
            payload = json.load(file) 
            file.close() 
            response = jsonify(payload) 
            return response, 200, {
                "link": "localhost:5000/conformance?f=application/json",
                "resource": "conformance"} 
        else:
            return "HTTP status code 406: not acceptable", 406 
    except:
        return "HTTP status code 500: internal server error", 500
\end{lstlisting}\label{appendixConformance}   

\newpage
\subsection{Quellcode Process List Endpoint}
\begin{lstlisting}[caption={Process List Endpoint}, style = Python]
#processes endpoint
@app.route('/processes', methods = ['GET']) 
def getProcesses():
    app.logger.info('/processes') 
    if(request.args.get('limit') == None or 
        int(request.args.get('limit')) <= 0 or 
        int(request.args.get('limit')) > 1000): 
        limit = 10 #set limit to default value
    else:
        limit = int(request.args.get('limit'))
    try:
        if(request.content_type == "text/html" or
            request.args.get('f')=="text/html" or 
            request.args.get('f') == None): 
                processList = [] #initialize list of processes
                processDescriptions = os.listdir("templates/json/processes") 
                counter = 0
                for i in processDescriptions:
                    file = open('templates/json/processes/' + i,) 
                    process = json.load(file) 
                    file.close() 
                    processList.append(process) 
                    counter += 1 
                    if(counter == limit): 
                        break 
                response = render_template('html/processes.html', 
                    processes=processList) 
                return response, 200, {
                    "link": "localhost:5000/processes?f=text/html", 
                    "resource": "processes"} 
        elif(request.content_type == "application/json" or 
                request.args.get('f')=="application/json"): 
            processList = [] #initialize list of processes
            processDescriptions = os.listdir("templates/json/processes")     
            for i in processDescriptions: 
                file = open('templates/json/processes/' + i,) 
                process = json.load(file) 
                file.close() 
                processList.append(process) 
            processes = {"processes": processList[0:limit],
                        "links": [ #add links to self and alternate
                            {
                            "href": "localhost:5000/processes?f=applicattion/json",
                            "rel": "self",
                            "type": "application/json"
                            },
                            {
                            "href": "localhost:5000/processes?f=text/html",
                            "rel": "alternate",
                            "type": "text/html"
                            }
                        ]}
            response = jsonify(processes) 
            return response, 200, {
                "link": "localhost:5000/processes?f=application/json", 
                "resource": "processes"} 
        else:
            return "HTTP status code 406: not acceptable", 406 
    except:
        return "HTTP status code 500: internal server error", 500 
\end{lstlisting}\label{appendixProcessList}   
\newpage
\subsection{Quellcode Process Description Endpoint}
\begin{lstlisting}[caption={Process Description Endpoint}, style = Python]
#process endpoint
@app.route('/processes/<processID>', methods = ['GET']) 
def getProcess(processID):
    app.logger.info('/processes/' + processID) 
    try:
        if(request.content_type == "text/html" or 
            request.args.get('f')=="text/html" or 
            request.args.get('f') == None): 
            if(os.path.exists('templates/json/processes/' 
            + str(processID) + 'ProcessDescription.json')): 
                file = open('templates/json/processes/' 
                + str(processID) 
                + 'ProcessDescription.json',) 
                process = json.load(file) 
                file.close() 
                response = render_template("html/Process.html", process=process) 
                return response, 200, {"link": "localhost:5000/processes/" 
                + str(processID) 
                + "?f=text/html", 
                "resource": str(processID)} 
            else:
                exception = render_template('html/exception.html', 
                title="No such process exception", 
                description="Requested process could not be found", 
                type="no-such-process")
                return exception, 404, {"resource": "no-such-process"}
        elif(request.content_type == "application/json" or
                request.args.get('f')=="application/json"): 
            if(os.path.exists('templates/json/processes/' 
            + str(processID) 
            + 'ProcessDescription.json')): 
                file = open('templates/json/processes/' 
                + str(processID) 
                + 'ProcessDescription.json',)
                payload = json.load(file) 
                file.close() 
                response = jsonify(payload) 
                return response, 200, {"link": "localhost:5000/processes/" 
                + str(processID) 
                + "?f=application/json", 
                "resource": str(processID)} 
            else:
                exception = {"title": "No such process exception", 
                "description": "Requested process could not be found", 
                "type": "no-such-process"}
                return exception, 404, {"resource": "no-such-process"} 
        else:
            return "HTTP status code 406: not acceptable", 406
    except:
        return "HTTP status code 500: internal server error", 500 
\end{lstlisting}\label{appendixProcessDescription}      

\newpage
\subsection{Quellcode Process Execution Endpoint}
\begin{lstlisting}[caption={Process Execution}, style = Python]
@app.route('/processes/<processID>/execution', methods = ['POST']) 
def executeProcess(processID):
    app.logger.info('/processes/' + processID + '/execution') 
    try:
        if(os.path.exists('templates/json/processes/' 
        + str(processID) 
        + 'ProcessDescription.json')): 
            data = json.loads(request.data.decode('utf8').replace("'", '"')) 
            inputParameters = utils.parseInput(processID, data)
            if(inputParameters == False):
                return "HTTP status code 400: bad request", 400 
            jobID = str(uuid.uuid4()) 
            created = str(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            os.mkdir("jobs/" + jobID) 
            os.mkdir("jobs/" + jobID + "/results/") 

            job_file = {"jobID": str(jobID), 
                        "processID": str(processID), 
                        "input": inputParameters[0], 
                        "output": inputParameters[2],
                        "responseType": inputParameters[1], 
                        "path": "jobs/" + jobID, 
                        "results": "jobs/" + jobID + "/results/", 
                        "downloads": "jobs/" + jobID + "/downloads/"} 
            json.dumps(job_file, indent=4) 
            with open("jobs/" + jobID + "/job.json", 'w') as f: 
                json.dump(job_file, f) 
            f.close()

            status_file = {"jobID": str(jobID), 
                            "processID": str(processID), 
                            "status": "accepted", 
                            "message": "Step 0/1", 
                            "type": "process", 
                            "progress": 0, 
                            "created": created, 
                            "started": "none", 
                            "finished": "none", 
                            "links": [ 
                                {
                                "href": "localhost:5000/jobs/" 
                                + jobID + "?f=application/json",
                                "rel": "self",
                                "type": "application/json",
                                "title": "this document as JSON"},
                                {
                                "href": "localhost:5000/jobs/" 
                                + jobID + "?f=text/html",
                                "rel": "alternate",
                                "type": "text/html",
                                "title": "this document as HTML"
                                }
                            ]}
            json.dumps(status_file, indent=4) #dump content
            with open("jobs/" + jobID + "/status.json", 'w') as f: #create file
                json.dump(status_file, f) #write content
            f.close() #close file

            response = jsonify(status_file) #create response
            return response, 201, {"location": "localhost:5000/jobs/" 
            + jobID + "?f=application/json", 
            "resource": "job"} 
            exception = {"title": "No such process exception", 
            "description": "Requested process could not be found", 
            "type": "no-such-process"}
            return exception, 404 
    except:
        return "HTTP status code 500: internal server error", 500
\end{lstlisting}\label{appendixProcessExecution}   

\newpage
\subsection{Quellcode Job Endpoint}
\begin{lstlisting}[caption={Job Endpoint}, style = Python]
#job endpoint for status and dismiss
@app.route('/jobs/<jobID>', methods = ['GET', 'DELETE']) 
def getJob(jobID):
    if(request.method == 'GET'):
        app.logger.info('[GET] /jobs/' + jobID)
        try:
            if(request.content_type == "application/json" or 
                request.args.get('f')=="application/json"): 
                if(os.path.exists('jobs/' + str(jobID) + '/status.json')):
                    file = open('jobs/' + str(jobID) + '/status.json')
                    data = json.load(file) 
                    file.close() 
                    response = jsonify(data) 
                    return  response, 200, {"link": "localhost:5000/jobs/" 
                    + str(jobID) 
                    + "?f=application/json",
                     "resource": "job - " 
                     + str(jobID)} 
                else:
                    exception = {"title": "No such job exception", 
                    "description": "No job with the requested jobID could be found", 
                    "type": "no-such-job"}
                    return exception, 404, {"resource": "no-such-job"} 
            elif(request.content_type == "text/html" or
                    request.args.get('f')=="text/html" or 
                    request.args.get('f') == None): 
                if(os.path.exists('jobs/' + str(jobID) + '/status.json')):
                    file = open('jobs/' + str(jobID) + '/status.json') 
                    job = json.load(file) #create response   
                    file.close() #close status.json
                    response = render_template("html/Job.html", job=job)
                    return response, 200, {"link": "localhost:5000/jobs/" + str(jobID) 
                    + "?f=text/html", 
                    "resource": "job - " 
                    + str(jobID)} 
                else:
                    exception = render_template('html/exception.html', title="No such job exception", description="No job with the requested jobID could be found", type="no-such-job")
                    return exception, 404, {"resource": "no-such-job"} #return not found if requested job is not found
            else:
                return "HTTP status code 406: not acceptable", 406 #return not acceptable if requested content-type is not supported
        except:
            return "HTTP status code 500: internal server error", 500 #return internal server error if something went wrong
        
    if(request.method == 'DELETE'):
        app.logger.info('[DELETE] /jobs/' + jobID) #add log entry when endpoint is called
        try:       
            if(os.path.exists('jobs/' + str(jobID) + '/status.json')): #check if jobID exists
                with open('jobs/' + str(jobID) + '/status.json', "r") as f: #open status.json
                    file = json.load(f) #load data from status.json
                    if(file["status"] != "dismissed"): #if job is not dismissed
                        file["status"] = "dismissed" #set status to dismissed
                        file["message"] = "job dismissed" #set emssage to dismissed
                        f.close() #close status.json
                        with open('jobs/' + str(jobID) + '/status.json', "w") as f: #write status.json
                            json.dump(file, f) #dump content
                            f.close() #close status.json                    
                        file = open('jobs/' + str(jobID) + '/status.json') #open status.json
                        data = json.load(file) #load data from status.json 
                        file.close() #close status.json
                        
                        if(request.content_type == "text/html" or #check requested content-type from request body
                            request.args.get('f')=="text/html" or 
                            request.args.get('f') == None):
                            file = open('jobs/' + str(jobID) + '/status.json') #open status.json
                            job = json.load(file) #create response   
                            file.close() #close status.json
                            response = render_template("html/Job.html", job=job) #render dynamic job
                            return response, 200, {"link": "localhost:5000/jobs/" + str(jobID) + "?f=text/html", "resource": "job-dismissed"} #return response and ok
                        else:
                            response = jsonify(data) #create response
                            return response, 200, {"link": "localhost:5000/jobs/" + str(jobID) + "?f=application/json", "resource": "job-dismissed"} #return response and ok with link und resource header
                    elif(request.content_type == "application/json" or #check requested content-type from request body
                            request.args.get('f')=="application/json"): #check requested content-type from inline request):
                        data = json.load(file) #load data from status.json 
                        file.close() #close status.json
                        response = jsonify(data) #create response
                        return response, 410, {"link": "localhost:5000/jobs/" + str(jobID) + "?f=application/json", "resource": "job-dismissed"} #return gone when job was already dismissed
            else:
                exception = {"title": "No such job exception", "description": "No job with the requested processID could be found", "type": "no-such-job"}
                return exception, 404 #return not found if requested job is not found 
        except:            
            return "HTTP status code 500: internal server error", 500 #return internal server error if something went wrong
\end{lstlisting}\label{appendixJob}  

\newpage
\subsection{Quellcode Echo Process}
\begin{lstlisting}[caption={Echo Process}, style = Python]
def echoProcess(job):
    if(checkForDismissal(job.path + '/status.json') == True):
        return
    
    setStarted(job.path + '/status.json')
    
    try:
        input = job.input[0]
        time.sleep(5)
    except:
        updateStatus(job.path + '/status.json', "failed", "The job has failed", "-")
        return
    
    if(checkForDismissal(job.path + '/status.json') == True):
        return
    
    result ={"result": input,
             "message": "This is an echo"}
    json.dumps(result, indent=4)
    with open(job.results + "result.json", 'w') as f: #create file
        json.dump(result, f) #write content
        f.close() #close file
    updateStatus(job.path + '/status.json', "successful", "Step 1 of 1 completed", "100")
    setFinished(job.path + '/status.json')
\end{lstlisting}\label{appendixEchoProcess}  

\section{Schemata}
\renewcommand{\lstlistingname}{Schema}  
\subsection{landingPage.yaml}
\begin{lstlisting}[caption={landingPage.yaml}, style = JSON]
type: object
required:
  - links
properties:
  title:
    type: string
    example: Example processing server
  description:
    type: string
    example: Example server 
  links:
    type: array
    items:
      $ref: "link.yaml"
\end{lstlisting}\label{appendixlandngPageyaml}  

\subsection{confClasses.yaml}
\begin{lstlisting}[caption={confClasses.yaml}, style = JSON]
type: object
required:
    - conformsTo
properties:
    conformsTo:
    type: array
    items:
        type: string
        example: "http://www.opengis.net/spec/ogcapi-processes-1/1.0/conf/core"
\end{lstlisting}\label{appendixconfClassesyaml}  

\subsection{processList.yaml}
\begin{lstlisting}[caption={processList.yaml}, style = JSON]
type: object
required:
  - processes
  - links
properties:
  processes:
    type: array
    items:
      $ref: "processSummary.yaml"
  links:
    type: array
    items:
      $ref: "link.yaml"
\end{lstlisting}\label{appendixprocessListyaml}  

\subsection{limit.yaml}
\begin{lstlisting}[caption={limit.yaml}, style = JSON]
name: limit
in: query
required: false
schema:
  type: integer
  minimum: 1
  maximum: 10000
  default: 10
style: form
explode: false
\end{lstlisting}\label{appendixlimityaml}  

\subsection{link.yaml}
\begin{lstlisting}[caption={link.yaml}, style = JSON]
type: object
required:
  - href
properties:
  href:
    type: string
  rel:
    type: string
    example: service
  type:
    type: string
    example: application/json
  hreflang:
    type: string
    example: en
  title:
    type: string
\end{lstlisting}\label{appendixlinkyaml}  

\subsection{processList.yaml}
\begin{lstlisting}[caption={processList.yaml}, style = JSON]
type: object
required:
    - processes
    - links
properties:
    processes:
    type: array
    items:
        $ref: "processSummary.yaml"
    links:
    type: array
    items:
        $ref: "link.yaml"
\end{lstlisting}\label{appendixprocessListyaml}  

\subsection{processSummary.yaml}
\begin{lstlisting}[caption={processSummary.yaml}, style = JSON]
allOf:
    - $ref: "descriptionType.yaml"
    - type: object
      required:
        - id
        - version
      properties:
        id:
          type: string
        version:
          type: string
        jobControlOptions:
          type: array
          items:
            $ref: "jobControlOptions.yaml"
        outputTransmission:
          type: array
          items:
            $ref: "transmissionMode.yaml"
        links:
          type: array
          items:
            $ref: "link.yaml"
\end{lstlisting}\label{appendixprocessSummaryyaml} 

\subsection{jobControlOptions.yaml}
\begin{lstlisting}[caption={jobControlOptions.yaml}, style = JSON]
type: string
enum:
    - sync-execute
    - async-execute
    - dismiss
\end{lstlisting}\label{appendixjobControlOptionsyaml} 

\subsection{transmissionMode.yaml}
\begin{lstlisting}[caption={transmissionMode.yaml}, style = JSON]
type: string
enum:
    - value
    - reference
default:
    - value
\end{lstlisting}\label{appendixtransmissionModeyaml} 

\subsection{process.yaml}
\begin{lstlisting}[caption={process.yaml}, style = JSON]
allOf:
  - $ref: "processSummary.yaml"
  - type: object
    properties:
      inputs:
        additionalProperties:
          $ref: "inputDescription.yaml"
      outputs:
        additionalProperties:
          $ref: "outputDescription.yaml"
\end{lstlisting}\label{appendixprocessyaml} 

\subsection{inputDescription.yaml}
\begin{lstlisting}[caption={inputDescription.yaml}, style = JSON]
allOf:
- $ref: "descriptionType.yaml"
- type: object
    required:
    - schema
    properties:
    minOccurs:
        type: integer
        default: 1
    maxOccurs:
        oneOf:
        - type: integer
            default: 1
        - type: string
            enum:
            - "unbounded"
    schema:
        $ref: "schema.yaml"
\end{lstlisting}\label{appendixinputDescriptionyaml} 

\subsection{outputDescription.yaml}
\begin{lstlisting}[caption={outputDescription.yaml}, style = JSON]
allOf:
- $ref: "descriptionType.yaml"
- type: object
    required:
    - schema
    properties:
    schema:
        $ref: "schema.yaml"
\end{lstlisting}\label{appendixoutputDescriptionyaml} 

\subsection{description.yaml}
\begin{lstlisting}[caption={description.yaml}, style = JSON]
type: object
properties:
    title:
    type: string
    description:
    type: string
    keywords:
    type: array
    items:
        type: string
    metadata:
    type: array
    items:
        $ref: "metadata.yaml"
    additionalParameters:
    allOf:
        - $ref: "metadata.yaml"
        - type: object
        properties:
            parameters:
            type: array
            items:
                $ref: "additionalParameter.yaml"
\end{lstlisting}\label{appendixdescriptionyaml} 

\subsection{jobList.yaml}
\begin{lstlisting}[caption={jobList.yaml}, style = JSON]
type: object
required:
    - jobs
    - links
properties:
    jobs:
    type: array
    items:
        $ref: "statusInfo.yaml"
    links:
    type: array
    items:
        $ref: "link.yaml"
\end{lstlisting}\label{appendixjobListyaml} 

\subsection{statusInfo.yaml}
\begin{lstlisting}[caption={statusInfo.yaml}, style = JSON]
type: object
required:
    - jobID
    - status
    - type
properties:
    processID:
        type: string
    type:
        type: string
        enum:
        - process
    jobID:
        type: string
    status:
        $ref: "statusCode.yaml"
    message:
        type: string
    created:
        type: string
        format: date-time
    started:
        type: string
        format: date-time
    finished:
        type: string
        format: date-time
    updated:
        type: string
        format: date-time
    progress:
        type: integer
        minimum: 0
        maximum: 100
    links:
        type: array
        items:
            $ref: "link.yaml"
\end{lstlisting}\label{appendixstatusInfoyaml}

\subsection{statusCode.yaml}
\begin{lstlisting}[caption={statusCode.yaml}, style = JSON]
type: string
nullable: false
enum:
    - accepted
    - running
    - successful
    - failed
    - dismissed
\end{lstlisting}\label{appendixstatusCodeyaml}

\section{Ressourcen}
\renewcommand{\lstlistingname}{Ressource}
\subsection{landingPage.html}
\begin{lstlisting}[caption={landingPage.html}, style = HTML]
<!DOCTYPE html>
<html>
	<body>
	<h1>links:</h1>
		<p>
			href:<a href="localhost:5000/?f=text/html">
            localhost:5000/?f=text/html</a><br>
			rel: self<br>
			type: text/html<br>
			title: This document as HTML
		</p>
		<p>
			href:<a href="localhost:5000/?f=application/json">
            localhost:5000/?f=application/json</a><br>
			rel: alternate<br>
			type: application/json<br>
			title: This document as JSON 
		</p>
		<p>
			href:<a href="localhost:5000/api?f=application/json">
            localhost:5000/apiDefinition?f=application/json</a><br>
			rel: service-desc<br>
			type: application/json<br>
			title: API definition for this endpoint as JSON
		</p>
		<p>
			href:<a href="localhost:5000/api?f=text/html">
            localhost:5000/apiDefinition?f=text/html</a><br>
			rel: service-desc<br>
			type: text/html<br>
			title: API definition for this endpoint as HTML
		</p>
		<p>
			href:<a href="localhost:5000/conformance?f=application/json">
            localhost:5000/conformance?f=application/json</a><br>
			rel: conformance<br>
			type: application/json<br>
			title: OGC API - Processes conformance classes implemented by this server as JSON
		</p>
		<p>
			href:<a href="localhost:5000/conformance?f=text/html">
            localhost:5000/conformance?f=text/html</a><br>
			rel: conformance<br>
			type: text/html<br>
			title: OGC API - Processes conformance classes implemented by this server as HTML
		</p>
		<p>
			href:<a href="localhost:5000/processes?f=application/json">
            localhost:5000/processes?f=application/json</a><br>
			rel: processes<br>
			type: application/json<br>
			title: Metadata about the processes as JSON
		</p>
		<p>
			href:<a href="localhost:5000/processes?f=text/html">
            localhost:5000/processes?f=text/html</a><br>
			rel: processes<br>
			type: text/html,<br>
			title: Metadata about the processes as HTML
		</p>
		<p>
			href:<a href="localhost:5000/jobs?f=application/json">
            localhost:5000/jobs?f=application/json</a><br>
			rel: jobs<br>
			type: application/json<br>
			title: The endpoint for job monitoring as JSON
		</p>
		<p>
			href:<a href="localhost:5000/jobs?f=text/html">
            localhost:5000/jobs?f=text/html</a><br>
			rel: jobs<br>
			type: text/html<br>
			title: The endpoint for job monitoring as HTML
		</p>
		<p>
			href:<a href="localhost:5000/coverage?f=application/json">
            localhost:5000/coverage?f=application/json</a><br>
			rel: coverage<br>
			type: application/json<br>
			title: The endpoint for coverage as JSON
		</p>
		<p>
			href:<a href="localhost:5000/coverage?f=text/html">
            localhost:5000/coverage?f=text/html</a><br>
			rel: coverage<br>
			type: text/html<br>
			title: The endpoint for coverage as HTML
		</p>
	</body>
</html>
\end{lstlisting}\label{appendixlandingPageHTML}  

\subsection{landingPage.json}
\begin{lstlisting}[caption={landingPage.json}, style = JSON]
{
    "links": [
    {
        "href": "localhost:5000/?f=application/json",
        "rel": "self",
        "type": "application/json",
        "title": "This document"
    },{
        "href": "localhost:5000/?f=text/html",
        "rel": "alternate",
        "type": "text/html",
        "title": "This document as HTML"
    },
    {
        "href": "localhost:5000/api?f=application/json",
        "rel": "service-desc",
        "type": "application/json",
        "title": "API definition for this endpoint as JSON"
    },
    {
        "href": "localhost:5000/api?f=text/html",
        "rel": "service-desc",
        "type": "text/html",
        "title": "API definition for this endpoint as HTML"
    },
    {
        "href": "localhost:5000/conformance?f=application/json",
        "rel": "conformance",
        "type": "application/json",
        "title": "OGC API - Processes conformance classes implemented by this server as JSON"
    },
    {
        "href": "localhost:5000/conformance?f=text/html",
        "rel": "conformance",
        "type": "text/html",
        "title": "OGC API - Processes conformance classes implemented by this server as HTML"
    },
    {
        "href": "localhost:5000/processes?f=application/json",
        "rel": "processes",
        "type": "application/json",
        "title": "Metadata about the processes as JSON"
    },
        {
        "href": "localhost:5000/processes?f=text/html",
        "rel": "processes",
        "type": "text/html",
        "title": "Metadata about the processes as HTML"
    },
    {
        "href": "localhost:5000/jobs?f=application/json",
        "rel": "jobs",
        "type": "application/json",
        "title": "The endpoint for job monitoring as JSON"
    },
        {
        "href": "localhost:5000/jobs?f=text/html",
        "rel": "jobs",
        "type": "text/html",
        "title": "The endpoint for job monitoring as HTML"
    },
    {
        "href": "localhost:5000/coverage?f=application/json",
        "rel": "coverage",
        "type": "application/json",
        "title": "The endpoint for coverage as JSON"
    },
        {
        "href": "localhost:5000/coverage?f=text/html",
        "rel": "coverage",
        "type": "text/html",
        "title": "The endpoint for coverage as HTML"
    }
    ]
}
\end{lstlisting}\label{appendixlandingPageJSON}  

\subsection{confClasses.html}
\begin{lstlisting}[caption={confClasses.html}, style = HTML]
<!DOCTYPE html>
<html>
    <body>
        <h1>conforms to:</h1>
            <p><a href="https://docs.ogc.org/is/18-062r2/18-062r2.html#toc21">
            https://docs.ogc.org/is/18-062r2/18-062r2.html#toc21</a></p>
            <p><a href="https://docs.ogc.org/is/18-062r2/18-062r2.html#toc40">
            https://docs.ogc.org/is/18-062r2/18-062r2.html#toc40</a></p>
            <p><a href="https://docs.ogc.org/is/18-062r2/18-062r2.html#toc41">
            https://docs.ogc.org/is/18-062r2/18-062r2.html#toc41</a></p>
            <p><a href="https://docs.ogc.org/is/18-062r2/18-062r2.html#toc42">
            https://docs.ogc.org/is/18-062r2/18-062r2.html#toc42</a></p>
			<p><a href="https://docs.ogc.org/is/18-062r2/18-062r2.html#toc47">
            https://docs.ogc.org/is/18-062r2/18-062r2.html#toc47</a></p>
			<p><a href="https://docs.ogc.org/is/18-062r2/18-062r2.html#toc53">
            https://docs.ogc.org/is/18-062r2/18-062r2.html#toc53</a></p>
            <p>
                <b>links:</b><br><br>
                <b>href:</b> <a href="localhost:5000/conformance?f=text/html">
                localhost:5000/conformance?f=text/html</a><br>
                <b>rel:</b> self<br>
                <b>type:</b> text/html<br>
                <b>title:</b> This Document as HTML<br>
                <br>
                <b>href:</b> <a href="localhost:5000/conformance?f=application/json">
                localhost:5000/conformance?f=application/json</a><br>
                <b>rel:</b> alternate<br>
                <b>type:</b> application/json<br>
                <b>title:</b> This document as JSON<br>
            </p>
    </body>
</html>
\end{lstlisting}\label{appendixconfClassesHTML}  

\subsection{confClasses.json}
\begin{lstlisting}[caption={confClasses.json}, style = JSON]
{
    "conformsTo": [
        "https://docs.ogc.org/is/18-062r2/18-062r2.html#toc21",
        "https://docs.ogc.org/is/18-062r2/18-062r2.html#toc40",
        "https://docs.ogc.org/is/18-062r2/18-062r2.html#toc41",
        "https://docs.ogc.org/is/18-062r2/18-062r2.html#toc42",
        "https://docs.ogc.org/is/18-062r2/18-062r2.html#toc47",
        "https://docs.ogc.org/is/18-062r2/18-062r2.html#toc53"
    ],
    "links": [
        {
            "href": "localhost:5000/conformance?f=application/json",
            "rel": "self",
            "type": "application/json",
            "title": "This Document as JSON"
        },
            {
            "href": "localhost:5000/conformance?f=text/html",
            "rel": "alternate",
            "type": "text/html",
            "title": "This Document as HTML"
        }
    ]
}
\end{lstlisting}\label{appendixconfClassesJSON}  

\subsection{processList.html}
\begin{lstlisting}[caption={processList.html}, style = HTML]
<!DOCTYPE html>
<html>
    <body>
        {% block body %}
        <p>
            {% for process in processes %}
            <b>Title:</b> {{process.title}}<br>
            <b>processID: </b>{{process.id}}<br>
            Description: {{process.description}}<br>
            Version: {{process.version}}<br>
            Job control options: {{process.jobControlOptions}}<br>
            Output transmission: {{process.outputTransmission}}<br>
            <p><b>inputs:</b></p>
            <p id='{{process.id}}inputs'><p>
            <p><b>outputs:</b></p>
            <p id='{{process.id}}outputs'><p>
            <script>
                var inputs = '{{process.inputs}}'
                var inputsString = inputs.replaceAll('&#39;', '"')
                var inputsJSON = JSON.parse(inputsString)
                var outputs = '{{process.outputs}}'
                var outputsString = outputs.replaceAll('&#39;', '"')
                var outputsJSON = JSON.parse(outputsString)
                console.log(outputsJSON)
                for (var key in inputsJSON) {
                    var inputs = document.createElement("p")
                    inputs.innerHTML = "<p><b>" + key 
                    + "</b><br>Description: " 
                    + inputsJSON[key].description 
                    + "<br><b>Schema:</b><br>Type: " 
                    + inputsJSON[key].schema.type + "</p>"
                    document.getElementById('{{process.id}}inputs').appendChild(inputs);
                }
                for (var key in outputsJSON) {
                    var outputs = document.createElement("p")
                    outputs.innerHTML = "<p><b>" + key 
                    + "</b><br><b>Description: </b>" 
                    + outputsJSON[key].description 
                    + "<br><b>Schema:</b><br>Type: " 
                    + outputsJSON[key].schema.type + "</p>"
                    document.getElementById('{{process.id}}outputs').appendChild(outputs);
                }
            </script>
            <p>
                <b>links: </b><br>
                href: <a href=localhost:5000/processes/{{process.id}}?f=application/json>
                localhost:5000/processes/{{process["id"]}}?f=application/json</a><br>
                rel: process<br>
                type: application/json<br>
                title: Process description<br><br>
                href: <a href=localhost:5000/processes/{{process.id}}?f=text/html>
                localhost:5000/processes/{{process["id"]}}?f=text/html</a><br>
                rel: process<br>
                type: text/html<br>
                title: Process description<br>
            </p>
            <p>======================================================================</p>
            {% endfor %}
        </p>
        {% endblock %}
        <p><b>links:</b><br>
            href:<a href="localhost:5000/processes?f=text/html">
            localhost:5000/processes?f=text/html</a><br>
            rel: self<br>
            type: text/html<br>
            title: This document<br>
            <br>
            href:<a href="localhost:5000/processes?f=application/json">
            localhost:5000/processes?f=application/json</a><br>
            rel: alternate<br>
            type: application/json<br>
            title: This document as JSON<br>
        </p>
    </body>
</html>
\end{lstlisting}\label{appendixprocessListHTML}  

\subsection{processDescription.html}
\begin{lstlisting}[caption={processDescription.html}, style = HTML]
<!DOCTYPE html>
<html>
	<body>
        <p>
            <b>processID:</b> {{process.id}}<br>
            <b>Title:</b> {{process.title}}<br>
            <b>Description:</b> {{process.description}}<br>
            <b>Version:</b> {{process.version}}<br>
            <b>Job control options:</b> {{process.jobControlOptions}}<br>
            <b>Output transmission mode:</b> {{process.outputTransmission}}
        </p>
        <p><b>inputs:</b></p>
        <p id='{{process.id}}'><p>
        <script>
            var inputs = '{{process.inputs}}'
            var inputsString = inputs.replaceAll('&#39;', '"')
            var inputsJSON = JSON.parse(inputsString)
            console.log(inputsJSON)
            for (var key in inputsJSON) {
                var newElement = document.createElement("p")
                newElement.innerHTML = "<p><b>" + key 
                + "</b><br>Description: " 
                + inputsJSON[key].description 
                + "<br><b>Schema:</b><br>Type: " 
                + inputsJSON[key].schema.type + "</p>"
                document.getElementById('{{process.id}}').appendChild(newElement);
            }
        </script>
        <p>
        <b>links:</b><br>
        href:<a href="localhost:5000/processes/{{process.id}}?f=text/html">
        localhost:5000/processes/{{process.id}}?f=text/html</a><br>
        rel: self<br>
        type: text/html<br>
        title: This document as HTML<br>
        <br>
        href:<a href="localhost:5000/processes/{{process.id}}?f=application/json">
        localhost:5000/processes/{{process.id}}?f=application/json</a><br>
        rel: alternate<br>
        type: application/json<br>
        title: This document as JSON
		</p>
	</body>
<html>
\end{lstlisting}\label{appendixprocessDescriptionHTML}  

\subsection{FloodMonitoringProcessDescription.json}
\begin{lstlisting}[caption={FloodMonitoringProcessDescription.json}, style = JSON]
{
  "id": "FloodMonitoring",
  "title": "Flood Monitoring",
  "description": "This process accepts a Test input and returns an echo",
  "version": "1.0.0",
  "jobControlOptions": [
    "async-execute", "dismiss"
  ],
  "outputTransmission": [
    "value"
  ],
  "inputs": {
    "preDate": {
      "title": "preDate",
      "description": "The input value",
      "schema": {
        "type": "string"
      }
	},
	"postDate": {
      "title": "postDate",
      "description": "The input value",
      "schema": {
        "type": "string"
      }
	},
	"username": {
      "title": "username",
      "description": "The input value",
      "schema": {
        "type": "string"
      }
	},
	"password": {
      "title": "password",
      "description": "The input value",
      "schema": {
        "type": "string"
      }
	},
	"bbox": {
		"title": "Bounding Box Input Example",
		"description": "This is an example of a BBOX literal input.",
			"schema": {
				"type": "object",
				"required": [
					"bbox"
				],
				"properties": {
					"bbox": {
						"type": "array",
						"oneOf": [
							{
								"minItems": 4,
								"maxItems": 4
							},
							{
								"minItems": 6,
								"maxItems": 6
							}
						],
						"items": {
							"type": "number"
						}
					},
					"crs": {
						"type": "string",
						"format": "uri",
						"default": "http://www.opengis.net/def/crs/OGC/1.3/CRS84",
						"enum": [
							"http://www.opengis.net/def/crs/OGC/1.3/CRS84",
							"http://www.opengis.net/def/crs/OGC/0/CRS84h"
						]
					}
				}
			}
		}
  },
  "outputs": {
   "bin": {
	  "title": "outputDocument",
	  "description": "The output document",
      "schema": {
			"type": "string",
			"contentEncoding": "binary",
			"contentMediaType": "application/tiff"
      }
    },
	"ndsi": {
	  "title": "outputDocument",
	  "description": "The output document",
      "schema": {
			"type": "string",
			"contentEncoding": "binary",
			"contentMediaType": "application/tiff"
      }
    }
  },
  "links": [
	{
		"href": "localhost:5000/processes/Echo?f=application/json",
		"rel": "self",
		"type": "application/json",
		"title": "This document"
	},
	{
		"href": "localhost:5000/processes/Echo?f=text/html",
		"rel": "alternate",
		"type": "text/html",
		"title": "This document as HTML"
	}
  ]
}
\end{lstlisting}\label{appendixFloodMonitoringProcessDescriptionJSON}  

\subsection{EchoProcessDescription.json}
\begin{lstlisting}[caption={EchoProcessDescription.json}, style = JSON]
{
    "id": "Echo",
    "title": "Echo",
    "description": "This process accepts a Test input and returns an echo",
    "version": "1.0.0",
    "jobControlOptions": [
        "async-execute", "dismiss"
    ],
    "outputTransmission": [
        "value"
    ],
    "inputs": {
        "echo": {
        "title": "echo",
        "description": "Value to be echoed",
        "schema": {
            "type": "string"
        }
        }
    },
    "outputs": {
        "outgoingEcho": {
        "title": "outgoingEcho",
        "description": "The output document containing the echoed value",
        "schema": {
            "type": "object",
            "contentMediaType": "application/json",
            "required": [
            "result",
            "message"
            ],
            "properties": {
            "result": {
                "type": "string"
            },
            "message": {
                "type": "string"
            }
            }
        }
        }
    },
    "links": [
        {
            "href": "localhost:5000/processes/Echo?f=application/json",
            "rel": "self",
            "type": "application/json",
            "title": "This document"
        },
        {
            "href": "localhost:5000/processes/Echo?f=text/html",
            "rel": "alternate",
            "type": "text/html",
            "title": "This document as HTML"
        }
    ]
    }     
\end{lstlisting}\label{appendixEchoProcessDescriptionJSON}  
\newpage
\restoregeometry
\section{Evaluation}
\subsection{Sichtbarkeit des Systemstatus}
Eine Anwendung sollte Nutzer*innen fortlaufend nicht nur über aufgetretene Fehler, sondern über möglichst 
viele Vorgänge informieren, sobald diese für den Nutzer*innen nützliche Informationen generieren. 
Dies sorgt dafür, dass Nutzer*innen die Folgen ihrer Interaktionen nachvollziehen können und ihre nächsten 
Interaktionen auf Basis der gewonnenen Interaktionen planen \cite{usability_engineering,nielsen_poster,heuristics_website}. 
Konkret sollten Nutzer*innen jederzeit Informationen zum Stand der von ihnen gestarteten Prozesse erhalten. 
Dies beginnt beim Erzeugen eines Jobs. Hier erhalten Nutzer*innen entweder die Information, dass der Job angelegt wurde oder 
dass die Eingaben nicht valide waren. Informationen zu erzeugten Jobs können über die Job Liste oder den Job Status 
beschafft werden. Dort kann der Nutzer*innen einsehen, ob der fragliche Job bereits gestartet wurde, in welchem 
Bearbeitungsschritt er sich befindet oder ob bereits Resultate abrufbar sind. Zusätzlich kann dem Job-Status auch 
entnommen werden zu wie viel Prozent der Job bereits bearbeitet ist oder ob Fehler aufgetreten sind. In letzterem
Fall kann zusätzlich ermittelt werden, welcher Prozessierungsschritt nicht erfolgreich beendet werden konnte. 
Allerdings erfolgt die Informationsweitergabe an den Nutzer*innen nicht automatisch, sondern nur auf dessen Initiative.   
Die Requirements-Class Callback des OGC API - Processes - Part 1: Core beschreibt jedoch einen Mechanismus mit dem
Nutzer*innen automatisiert zum Stand der von ihnen gestarteten Prozesse informiert werden können. Dies könnte nach 
jedem Prozessierungsschritt oder bei einer Statusänderung erfolgen. 

\subsection{Nutzerkommunikation}
Anwendungen sollten in möglichst einfacher und verständlicher Form mit dem Nutzer*innen kommunizieren. 
Befehle und Benachrichtigungen sollten möglichst in einer Sprache verfasst sein, welche Nutzer*innen direkt 
verstehen und interpretieren können. Die kommunizierten Konzepte sollten leicht mit der realen Welt 
verknüpfbar sein \cite{usability_engineering,nielsen_poster,heuristics_website}.
Die prototypische Anwendung verwendet Englisch als Systemsprache. Diese kann von einer großen 
Nutzergemeinschaft gelesen und verstanden werden. Requests werden in einer Form verfasst, welche 
ebenfalls direkt Kontext und Intention verstehen lässt. So wird bei Abfrage eines Jobs \verb|/results| 
angehängt, um zu signalisieren, dass die Ergebnisse abgefragt werden sollen. In ähnlicher Weise wird einem 
Request an einen Prozess \verb|/execute| angehängt, um den Prozess zu starten. Die Interaktion 
mit der Anwendung erfolgt also in quasi natürlicher Sprache. 

\subsection{Nutzerkontrolle und Wiedererkennbarkeit}
Eine Anwendung sollte Nutzern möglichst viel Freiheit bei der Interaktion mit den bereitgestellten Ressourcen 
erlauben. Da Fehler passieren können, sollten Nutzer*innen zum Beispiel in die Lage versetzt werden, 
durch Interaktionen gestartete Prozesse abzubrechen. Außerdem sollte beim Arbeiten mit einer Anwendung das Erinnerungsvermögen 
der Nutzer*in so wenig wie möglich belastet werden. Stattdessen sollten viele Inhalte wiedererkennbar und so 
direkt mit einem Kontext versehen werden können \cite{usability_engineering,nielsen_poster,heuristics_website}.
Da die prototypische Implementierung die Requirements-Class Dismiss implementiert, können Nutzer*innen von ihnen 
gestartete Jobs vor oder während der Prozessierung abbrechen. 
Haben Nutzer*innen die ID ihres Jobs und dessen Parameter vergessen, gibt es bisher kaum Möglichkeiten, den 
von ihnen angelegten Job schnell zu identifizieren, da diese nicht an Nutzerkonten oder Kennungen geknüpft sind.
Wird jedoch auch die bereits beschriebene Requirements-Class Callback implementiert, wird beim Anlegen eines Jobs ein 
Subscriber-Objekt erzeugt. Dieses könnte auch dazu dienen, einen Job klar einem Nutzer*innen zuzuordnen. Diese Zuordnung 
könnte zum Beispiel genutzt werden, um die Job Liste nur auf Jobs einer bestimmten Nutzer*in einzuschränken oder 
zu verhindern das Jobs von Nutzer*innen gelöscht werden können welche diesen nicht erzeugt haben.

\subsection{Flexibilität und Effiziente Nutzung}
Um Nutzer*innen die Möglichkeit zu geben, bereits erlernte Interaktionen schneller durchzuführen, sollte eine 
Anwendung Shortcuts zu bestimmten Funktionalitäten bereitstellen \cite{usability_engineering,nielsen_poster}. 
Die Anwendung bietet momentan keine Shortcuts zu Funktionen. Die im Rahmen des HATEOAS Architekturstils umgesetzten 
Verknüpfungen innerhalb der Ressourcen deuten auf die Ressource im jeweils anderen Media-Type. Die Prozessbeschreibungen 
enthalten darüber hinaus eine Verknüpfung mit der Relation \verb|execution|. 
Eine Erweiterung der Ressourcen nach dem HATEOAS Architekturstils könnte Interaktionen mit diesen noch effizienter 
gestalten. So könnten die Jobbeschreibungen um Verknüpfungen mit den Relationen \verb|results| und \verb|dismiss| erweitert werden, um sämtliche
Interaktionsmöglichkeiten direkt in der Ressource aufzuführen. 

\subsection{Konsistenz und Standards}
Eine Anwendung sollte hinsichtlich der von ihr bereitgestellten Funktionen unbedingt konsistent sein. Dies bedeutet das 
Nutzer*innen identische Resultate für identische Anfragen erwarten können \cite{usability_engineering,nielsen_poster,heuristics_website}. 
Zusätzlich kann es hilfreich sein, wenn die Anwendung weit verbreitete Standards und Konventionen einhält, da Nutzer*innen möglicherweise 
bereits mit diesen vertraut sind.  
Die Konsistenz der Interaktionen wird unter anderem durch die Anwendung des REST Architekturstils sichergestellt da hier der Zustand des Systems keinen 
Einfluss auf die angefragten Ressourcen nimmt. Die Verwendung des OGC API - Processes - Part 1: Core Standards sorgt zusätzlich dafür, dass auch bei 
Weiterentwicklung oder Erweiterung der Anwendung die Schnittstellen stabil bleiben. Dies kann zusätzlich durch den Test-Suit sichergestellt werden.
%Zumindest für den Bereich der Geoinformatik ist das OGC ein maßgebliches Standardisierungsgremium. Daher kann davon ausgegangen werden, dass OGC 
%Standards von Nutzer*innen aus diesem Bereich gut verstanden und genutzt werden können. 

\subsection{Fehlervermeidung}
Nutzerfreundliche Anwendungen versorgen den Nutzer*innen nicht nur mit detaillierten Fehlermeldungen, sondern versuchen Fehler aktiv zu vermeiden. 
Dies erhöht die Stabilität der Anwendung, da Fehler, welche möglicherweise zum Absturz der Anwendung führen, vermieden werden können. 
Die Anwendung kann jedoch auch leichter verwendet werden. So können Mehrfacheingaben und lange Wartezeiten bis zum Fehlschlag eines 
Prozesses vermieden werden \cite{usability_engineering,nielsen_poster,heuristics_website}. 
Wird ein Prozess von einer Nutzer*in ausgeführt, werden zunächst seine Eingaben überprüft. Sind diese nicht valide, wird kein Job angelegt, auf dessen 
Fehlschlag eine Nutzer*innen warten müsste. Allerdings erhält die Nutzer*in bisher keine Informationen darüber, welche Eingabeparameter nicht validiert werden 
konnten. Jedoch wird ein nicht valider \verb|limit|-Parameter auf den Standardwert gesetzt und mit der Prozessierung des Requests fortgefahren.
Mechanismen, welche bei fehlerhaften Eingaben einen Standardwert verwenden oder den wahrscheinlichsten Wert ermitteln, können jedoch ergänzt werden. 

\subsection{Fehlerbehandlung}
Treten doch Fehler auf, so müssen die Fehlermeldungen einfach und verständlich sein. Im Optimalfall enthalten die Fehlermeldungen auch eine detaillierte 
Fehlermeldung sowie Lösungsvorschläge. 
Ausschließlich maschinenlesbare Fehlercodes sollten also vermieden werden \cite{usability_engineering,nielsen_poster,heuristics_website}.
Viele mögliche Fehler werden durch das Versenden von Responses mit einem passenden HTTP-Statuscode abgefangen. Der Zahlencode allein ist wenig 
aussagekräftig. Ein Response mit einem auf einen Fehler hinweisenden Statuscode enthält jedoch eine textuelle Information aus der ersichtlich wird, 
was der Grund für den Fehler war. Manche Fehler lösen auch das Versenden einer Exception aus. Aus dieser wird klar ersichtlich, was der
Grund für den Fehler ist. Lediglich Fehler, welche während der Prozessierung eines Jobs auftreten, lassen sich mithilfe von Fehlermeldungen 
nur schwer nachvollziehen. Zwar kann dem Job-Status in einem solchen Fall entnommen werden, welcher Prozessierungsschritt nicht erfolgreich durchgeführt werden 
konnte, aber die Gründe lassen sich den Fehlermeldungen nicht entnehmen. Lösungsvorschläge werden von der Anwendung bisher nicht gemacht. 
Ein Abstürzen der Anwendung wird häufig unter Verwendung von \verb|try|- und \verb|except|-Blöcken 
vermieden. Tritt während der Prozessierung ein Fehler auf, wird der Status des Jobs entsprechend geändert und dessen weitere Bearbeitung abgebrochen. 
Um Nutzer*innen die Möglichkeit zu geben, ihre Eingaben nach einem Fehler zu korrigieren, könnten die vom Programm generierten Ausgaben Teil der Fehlermeldung sein. 
Versierte Nutzer*innen könnten so Rückschlüsse auf mögliche Ursachen ziehen. Manche, häufig gemachte Fehler, könnten auch explizit abgefangen werden. Dazu zählen 
das Verwechseln von den Zeitstempeln von vor und nach dem Überschwemmungsereignis oder die Angabe von invaliden Koordinaten der Bounding Box.  

\subsection{Hilfe und Dokumentation}
Eine Anwendung sollte nicht nur in einer für Softwareentwickler verständlichen Art und Weise dokumentiert sein. Zusätzlich kann es von Vorteil sein, wenn 
eine Dokumentation interaktiv durchsucht werden kann, um zu lösende Problem schnell zu beheben. \cite{usability_engineering,nielsen_poster,heuristics_website}.
Die prototypische Implementierung enthält eine in die Anwendung integrierte Dokumentation. Diese beschreibt detailliert sämtliche implementierten Funktionen. 
Da die Dokumentation dem OpenAPI 3.0 Standard entspricht, ist sie sowohl menschen- als auch maschinenlesbar. Alle Eingabemöglichkeiten und zu erwartenden 
Ausgaben werden für jeden Endpoint der API aufgeführt. Zusätzlich liegen zu den Eingaben und Ressourcen Schemata vor, welche die Struktur dieser beschreiben.
Die Funktionsweise der von der Anwendung angebotenen Prozesse kann den entsprechenden Prozess-Beschreibungen entnommen werden. In diesen sind die Kontrolloptionen, 
verfügbare Transmissions-Modi sowie mögliche Ein- und Ausgaben aufgeführt.
Um die Dokumentation interaktiver zu gestalten, bieten Plattformen wie SwaggerHub Möglichkeiten zum Aufsetzten von Anwendungs-Mockups aus API-Definitionen. 
Die eigentlichen Prozesse sind zwar nicht Teil dieser Mockups jedoch können Nutzer*innen sich auf diese Weise vertraut mit der API machen. 
  


